# Throughout the codes, we denote by F(a,b) a free group of rank 2 generated by the set {a,b} where a^{-1} = A and b^{-1} = B.

# I. Preliminary. We define some functions as follows.

# 1. reduce(W) freely reduces a word W in F(a,b).
# Ex. Let W = baABa be a word in F(a,b). Then reduce(W) = a.
def reduce(W) :
    while True :
        if "aA" in W :
            i = W.find("aA")
            W = W[0:i] + W[i+2:]
            #print("aA at",i,"reduced to",W)
        elif "Aa" in W :
            i = W.find("Aa")
            W = W[0:i] + W[i+2:]
            #print("Aa at",i,"reduced to",W)
        elif "bB" in W :
            i = W.find("bB")
            W = W[0:i] + W[i+2:]
            #print("bB at",i,"reduced to",W)
        elif "Bb" in W :
            i = W.find("Bb")
            W = W[0:i] + W[i+2:]
            #print("Bb at",i,"reduced to",W)
        else :
            break
    #print("Reduced:",W)
    return W

# 2. inverse(W) finds the inverse of a word W in F(a,b).
# Ex. Let W = baABa be a word in F(a,b). Then inverse(W) = AbaAB.
def inverse(W) :
    W = W[::-1] # Reverse the order of W
    #print(W)
    W1 = str()
    for x in W :
        if x is "A" :
            y = x.lower()
            #print(x,"lower to",y)
            W1 = W1 + y
        if x is "B" :
            y = x.lower()
            #print(x,"lower to",y)
            W1 = W1 + y
        if x is "a" :
            X = x.upper()
            #print(x,"upper to",X)
            W1 = W1 + X
        if x is "b" :
            X = x.upper()
            #print(x,"upper to",X)
            W1 = W1 + X
    #print("Inverse:",W1)
    return W1

# 3. cyclic(W) finds all freely reduced cyclic permutations of a word W in F(a,b).
# Ex. Let W = abA be a word in F(a,b). Then cyclic(W) = {abA, b, b}.
def cyclic(W) :
    L = list()
    for i in range(len(W)) :
        if i == 0 :
            reducedW = reduce(W)
            #print(reducedW)
            L.append(reducedW)
        if i > 0 :
            #print(W[i:]+W[0:i])
            reducedW = reduce(W[i:]+W[0:i])
            L.append(reducedW)
    #print("Reduced cyclics:",L)
    return L

# 4. CP(x,y) is the conjugate problem for two words x and y in F(a,b). This is due to x and y are conjugate iff freely reduced x (or y, respectively) is a freely reduced
# cyclic permutation of y (or x, respectively). Note that the complexity of CP() is linear.
# Ex. CP(abA,a) = "abA and a not conjugate".
def CP(x,y) :
    Rx = reduce(x)
    Ry = reduce(y)
    L_x = cyclic(x)
    L_y = cyclic(y)
    L1 = list()
    for i in range(len(L_x)) : # Test if the freely reduced y is a freely reduced cyclic permutation of x
        if Ry == L_x[i] :
            #print(Ry,"conjugated by",Rx[0:i],"to",Rx)
            #print(x,"and",y,"conjugate")
            return Rx[0:i]
            break
        if Ry != L_x[i] :
            L1.append(L_x[i])
    L2 = list()
    for i in range(len(L_y)) : # Test if the freely reduced x is a freely reduced cyclic permutation of y
        if Rx == L_y[i] :
            #print(Rx,"conjugated by",Ry[0:i],"to",Ry)
            #print(x,"and",y,"conjugate")
            return Ry[0:i]
            break
        if Rx != L_y[i] :
            L2.append(L_y[i])
    if len(L1) == len(L_x) and len(L2) == len(L_y) :
        print(x,"and",y,"not conjugate")

# 5. GCP(A,B) is the conjugacy (search) problem for two sets A and B of freely reduced words in F(a,b), where A = {a_{1},...,a_{k}} and B = {b_{1},...,b_{k}}. 
# This is due to Bridson, M. R., & Howie, J. (2005). Conjugacy of finite subsets in hyperbolic groups. International Journal of Algebra and Computation, 15(04), 725-756.
# It follows that the complexity of GCP() is linear.
# Ex. Let A = {a, abA} and B = {baB, b}. Then GCP(A,B) = {bA}.
def GCP(A,B) :
    # 5.1 Test the conjugacy of A and B
    g_1 = CP(A[0],B[0]) # Test if a_{1} and b_{1} are conjugate
    if g_1 is None :
        print(A,"and",B,"not conjugate\n")
        quit()
    # 5.2 Finding a max length of word in A and B
    L_A = list()
    for i in range(len(A)) :
        l = int(len(A[i]))
        L_A.append(l)
    #print("Length of words",A,"is",L_A)
    m_A = max(L_A)
    #print("Max length in",A,"is",m_A)
    L_B = list()
    for i in range(len(B)) :
        l = int(len(B[i]))
        L_B.append(l)
    #print("Length of words",B,"is",L_B)
    m_B = max(L_B)
    #print("Max length in",B,"is",m_B)
    L_AB = [m_A, m_B]
    m_AB = max(L_AB)
    #print("Max length in",A,"and",B,"is",m_AB)
    # 5.3 Find the conjugator for A and B
    L = list()
    for n in range(0,m_AB) :
        c = n * A[0] # c = a_{1}^{n} is a centerlizer of a_{1} for any integer n
        c_ = inverse(c)
        for a_i, b_i in zip(A,B) :
            if reduce(g_1 + c + a_i + inverse(g_1 + c)) == reduce(b_i) : # Test if (g_1c)a_i(g_1c)^{-1} = b_i
                #print("Try a conjugator:",g_1,c)
                L.append(g_1+c)
            if reduce(g_1 + c + a_i + inverse(g_1 + c)) != reduce(b_i) :
                pass
                #print(g_1,c,"is not a conjugator")
            if c_ != "" and reduce(g_1 + c_ + a_i + inverse(g_1 + c_)) == reduce(b_i) : # Test if (g_1c_)a_i(g_1c_)^{-1} = b_i
                #print("Try a conjugator:",g_1,c_)
                L.append(g_1+c_)
            if c_ != "" and reduce(g_1 + c_ + a_i + inverse(g_1 + c_)) != reduce(b_i) :
                #print(g_1,c_,"is not a conjugator")
                break
    D = dict()
    for x in L :
        if x not in D :
            D[x] = 1
        else :
            D[x] += 1
    #print(D)
    if max(D.values()) < len(A) :
        print(A,"and",B,"not conjugate\n")
        quit()
    L1 = list()
    for x in D :
        if D[x] == max(D.values()) :
            L1.append(x)
    print("A conjugator for",A,"and",B,"is",L1[0])
    return L1[0]

# II. Cryptanalysis of the Anshel-Anshel-Goldfeld protocol in F(a,b).

print()
print("---------------------------------------------------------------")
print("Cryptanalysis of the Anshel-Anshel-Goldfeld public key protocol")
print("   in the free group F(a,b) where a^{-1} = A and b^{-1} = B.   ")
print("---------------------------------------------------------------")
print()

# 1. Collect public information, i.e., F(a,b), two sets A and B of words in F(a,b) and sendings.
while True:
    Gp = input("Confirm the group: ")
    if Gp != "F(a,b)" :
        print("Wrong group!")
    if Gp == "F(a,b)" :
        break
print()
print("Confirm the sets (each pair of words must be entered by a space).")
s_A = input("A: ")
A = s_A.split()
s_B = input("B: ")
B = s_B.split()
print()
print("Confirm the sendings (each pair of words must be entered by a space).")
s_NF_A = input("S_A: ")
NF_A = s_NF_A.split() # With the notation in AAG, b_{j}^{a} for all 1 <= j <= m
s_NF_B = input("S_B: ")
NF_B = s_NF_B.split() # With the notation in AAG, a_{i}^{b} for all 1 <= i <= n

print()

# 2. Find the secret common key k = [a,b] = aba^{-1}b^{-1}.
a = GCP(B, NF_A)
b = GCP(A, NF_B)
print()
#print("Possible password for A:",a)
#print("Possible password for B:",b)
#print()
k = reduce(a+b+inverse(a)+inverse(b))
#print(k)
print("Their secret common key:",k)

print()
